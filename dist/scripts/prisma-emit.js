#!/usr/bin/env ts-node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const internals_1 = require("@prisma/internals");
const fs_1 = require("fs");
const path_1 = require("path");
const yargs_1 = __importDefault(require("yargs"));
async function main() {
    const argv = await yargs_1.default
        .option('schema', {
        alias: 's',
        type: 'string',
        description: 'Path to your schema.prisma',
        default: 'prisma/schema.prisma',
    })
        .help()
        .parseAsync();
    const schemaPath = (0, path_1.resolve)(process.cwd(), argv.schema);
    const datamodel = (0, fs_1.readFileSync)(schemaPath, 'utf-8');
    // 1. load schema via datamodel content
    const dmmf = await (0, internals_1.getDMMF)({ datamodel });
    // 2. collect all model names
    const models = dmmf.datamodel.models.map((m) => m.name);
    // 3. build the declarations
    const lines = [
        `// Generated by prisma-emit, do not edit`,
        `import { Prisma } from '@prisma/client'`,
        ``,
        `declare module '@prisma/client' {`,
        `  namespace Prisma {`,
    ];
    for (const model of models) {
        for (const op of ['Create', 'Update', 'Upsert']) {
            lines.push(`    interface ${model}${op}Args {`, `      emit?: boolean`, `    }`);
        }
    }
    lines.push(`  }`, `}`);
    // 4. write to your types folder
    const outPath = (0, path_1.resolve)(process.cwd(), 'types', 'prisma-emit.d.ts');
    (0, fs_1.writeFileSync)(outPath, lines.join('\n') + '\n');
    console.log(`âœ…  Generated ${outPath}`);
}
main().catch((e) => {
    console.error(e);
    process.exit(1);
});
